#!/usr/bin/env python3

import asyncio
import config
import os
import out
import pydle
import sys
import time
import traceback

from misc import whoami

class System(pydle.Client):
    async def on_connect(self):
        await super().on_connect()

        print('[irc] connected!')

        self.modules = {}
        self.help = {}
        self.userinfo = {}
        self.aliases = {}

        # handle commands, raw PRIVMSGs,
        # and messages that match a regex,
        # respectively.
        self.handle_cmd = {}
        self.handle_raw = {}
        self.handle_reg = {}

        # HACK: avoid executing commands from
        # channel history playback
        self.ignore_cmd = 0

        print('[modules] loading modules...')
        await self.load_mods()
        print('[irc] joining channels')
        for i in config.initial_chans:
            await self.join(i)
        print('[irc] done!')

        if config.set_botmode:
            print('[irc] attempting to set mode +B')
            await self.set_mode(self.nickname, '+B')

    async def load_mods(self):
        for i in [s for s in os.listdir('mod') if '.py' in s]:
            i = i[:-3]
            print('[modules] loading', i)
            m = __import__('mod.' + i)
            m = eval('m.' + i)
            await m.init(self)
            self.modules[i] = m

    async def on_join(self, chan, by):
        await super().on_join(chan, by)

        if by == self.nickname:
            self.ignore_cmd = time.time() + 3

    async def on_invite(self, chan, by):
        await super().on_invite(chan, by)

        print('[irc] received invite by {} to {}'.format(by, chan))

        if config.join_on_invite:
            if chan not in config.bannedchans:
                await self.join(chan)

    async def on_message(self, chan, source, msg):
        await super().on_message(chan, source, msg)

        # not sure whether it's a pydle bug or irc quirk...
        # but when PM's are sent, we receive them twice!
        # once in the <self.nickname> chan and once in the
        # <source> chan... so just ignore one of them
        if chan == self.nickname:
            return

        if not time.time() > self.ignore_cmd:
            return

        for i in self.handle_raw:
            await self.handle_raw[i](self, chan, source, msg)

        if source == self.nickname:
            return

        if msg == '!botlist' or msg == '!rollcall':
            if config.respond_to_rollcall:
                await whoami(self, chan, source, msg)
            return

        if not chan in self.asleep:
            self.asleep[chan] = time.time()

        for i in self.handle_reg:
            # (<regex>, <function>)
            if not self.handle_reg[i][0].match(msg):
                continue
            await self.handle_reg[i][1](self, chan, source, msg)

        if not msg[:len(self.prefix)] == self.prefix:
            return

        msg = msg[len(self.prefix):]
        cmd = msg.split(' ')[0]
        msg = msg[len(cmd) + 1:]

        # check if the command might be an alias
        matches = {k for k, v in self.aliases.items() if cmd in v}
        if len(matches) > 0 and cmd not in self.handle_cmd:
            cmd = list(matches)[0]

        if cmd in self.handle_cmd:
            print('[cmd] recieved command "{}" from "{}" in "{}"'
                .format(cmd, source, chan))

            if self.asleep[chan] < time.time() or cmd == 'admin':
                try:
                    await self.handle_cmd[cmd](self, chan, source, msg)
                except Exception as e:
                    traceback.print_tb(e.__traceback__)
                    await out.msg(self, 'oops', chan,
                        ['segmentation fault', repr(e)])
                    return

    async def resolve(self, nickname):
        """
        Cache whois information for nicknames
        """

        # FIXME: deal with users leaving, joining, or
        # maybe even changing nicks
        if not nickname in self.userinfo:
            self.userinfo[nickname] = await self.whois(nickname)
        return self.userinfo[nickname]

    async def is_admin(self, nickname):
        info = await self.whois(nickname)
        # check if they are identified
        if not 'account' in info:
            return False

        return info['account'] in config.admins

    async def on_private_message(self, chan, source, msg):
        await super().on_private_message(chan, source, msg)
        await self.on_message(source, source, msg)

    async def on_user_mode_change(self, modes):
        await super().on_user_mode_change(modes)
        print('[irc] mode changed: {}'.format(modes))

if __name__ == '__main__':
    client = System(config.nickname, realname=config.realname)
    client.prefix = config.prefix
    client.asleep = {}
    client.run(config.server, tls=config.tls, tls_verify=config.tls_verify)
